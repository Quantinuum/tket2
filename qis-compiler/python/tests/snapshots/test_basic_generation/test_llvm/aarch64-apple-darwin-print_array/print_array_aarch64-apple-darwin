; ModuleID = 'hugr'
source_filename = "hugr"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-apple-darwin"

@"e_Array alre.5A300C2A.0" = private constant [57 x i8] c"8EXIT:INT:Array already contains an element at this index"
@"e_Array elem.E746B1A3.0" = private constant [43 x i8] c"*EXIT:INT:Array element is already borrowed"
@"e_Some array.A77EF32E.0" = private constant [48 x i8] c"/EXIT:INT:Some array elements have been borrowed"
@"e_Array cont.EFA5AC45.0" = private constant [70 x i8] c"EEXIT:INT:Array contains non-borrowed elements and cannot be discarded"
@res_cs.46C3C4B5.0 = private constant [16 x i8] c"\0FUSER:BOOLARR:cs"
@res_is.F21393DB.0 = private constant [15 x i8] c"\0EUSER:INTARR:is"
@res_fs.CBD4AF54.0 = private constant [17 x i8] c"\10USER:FLOATARR:fs"
@"e_No more qu.3B2EEBF0.0" = private constant [47 x i8] c".EXIT:INT:No more qubits available to allocate."
@"e_Expected v.E6312129.0" = private constant [46 x i8] c"-EXIT:INT:Expected variant 1 but got variant 0"
@"e_Expected v.2F17E0A9.0" = private constant [46 x i8] c"-EXIT:INT:Expected variant 0 but got variant 1"

define private fastcc void @__hugr__.main.1() unnamed_addr {
alloca_block:
  %0 = tail call i8* @heap_alloc(i64 800)
  %1 = bitcast i8* %0 to double*
  %2 = tail call i8* @heap_alloc(i64 16)
  %3 = bitcast i8* %2 to i64*
  tail call void @llvm.memset.p0i64.i64(i64* noundef nonnull align 1 dereferenceable(16) %3, i8 -1, i64 16, i1 false)
  %4 = tail call i8* @heap_alloc(i64 800)
  %5 = bitcast i8* %4 to i64*
  %6 = tail call i8* @heap_alloc(i64 16)
  %7 = bitcast i8* %6 to i64*
  tail call void @llvm.memset.p0i64.i64(i64* noundef nonnull align 1 dereferenceable(16) %7, i8 -1, i64 16, i1 false)
  %8 = tail call i8* @heap_alloc(i64 80)
  %9 = bitcast i8* %8 to i64*
  %10 = tail call i8* @heap_alloc(i64 8)
  %11 = bitcast i8* %10 to i64*
  store i64 -1, i64* %11, align 1
  br label %cond_20_case_1

cond_20_case_1:                                   ; preds = %alloca_block, %cond_exit_20
  %"15_0.sroa.0.0955" = phi i64 [ 0, %alloca_block ], [ %12, %cond_exit_20 ]
  %12 = add nuw nsw i64 %"15_0.sroa.0.0955", 1
  %qalloc.i = tail call i64 @___qalloc()
  %not_max.not.i = icmp eq i64 %qalloc.i, -1
  br i1 %not_max.not.i, label %id_bb.i, label %reset_bb.i

reset_bb.i:                                       ; preds = %cond_20_case_1
  tail call void @___reset(i64 %qalloc.i)
  br label %id_bb.i

id_bb.i:                                          ; preds = %reset_bb.i, %cond_20_case_1
  %13 = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %qalloc.i, 1
  %14 = select i1 %not_max.not.i, { i1, i64 } { i1 false, i64 poison }, { i1, i64 } %13
  %.fca.0.extract.i = extractvalue { i1, i64 } %14, 0
  br i1 %.fca.0.extract.i, label %__barray_check_bounds.exit, label %cond_303_case_0.i

cond_303_case_0.i:                                ; preds = %id_bb.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @"e_No more qu.3B2EEBF0.0", i64 0, i64 0))
  unreachable

__barray_check_bounds.exit:                       ; preds = %id_bb.i
  %15 = lshr i64 %"15_0.sroa.0.0955", 6
  %16 = getelementptr inbounds i64, i64* %11, i64 %15
  %17 = load i64, i64* %16, align 4
  %18 = shl nuw nsw i64 1, %"15_0.sroa.0.0955"
  %19 = and i64 %17, %18
  %.not.i = icmp eq i64 %19, 0
  br i1 %.not.i, label %panic.i, label %cond_exit_20

panic.i:                                          ; preds = %__barray_check_bounds.exit
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

cond_exit_20:                                     ; preds = %__barray_check_bounds.exit
  %.fca.1.extract.i = extractvalue { i1, i64 } %14, 1
  %20 = xor i64 %17, %18
  store i64 %20, i64* %16, align 4
  %21 = getelementptr inbounds i64, i64* %9, i64 %"15_0.sroa.0.0955"
  store i64 %.fca.1.extract.i, i64* %21, align 4
  %exitcond.not = icmp eq i64 %12, 10
  br i1 %exitcond.not, label %loop_out, label %cond_20_case_1

loop_out:                                         ; preds = %cond_exit_20
  %22 = load i64, i64* %11, align 4
  %23 = and i64 %22, 1
  %.not.i846 = icmp eq i64 %23, 0
  br i1 %.not.i846, label %__barray_mask_borrow.exit, label %panic.i847

panic.i847:                                       ; preds = %loop_out
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

__barray_mask_borrow.exit:                        ; preds = %loop_out
  %24 = xor i64 %22, 1
  store i64 %24, i64* %11, align 4
  %25 = load i64, i64* %9, align 4
  tail call void @___rxy(i64 %25, double 0x400921FB54442D18, double 0.000000e+00)
  %26 = load i64, i64* %11, align 4
  %27 = and i64 %26, 1
  %.not.i848 = icmp eq i64 %27, 0
  br i1 %.not.i848, label %panic.i849, label %__barray_mask_return.exit850

panic.i849:                                       ; preds = %__barray_mask_borrow.exit
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

__barray_mask_return.exit850:                     ; preds = %__barray_mask_borrow.exit
  %28 = xor i64 %26, 1
  store i64 %28, i64* %11, align 4
  store i64 %25, i64* %9, align 4
  %29 = load i64, i64* %11, align 4
  %30 = and i64 %29, 4
  %.not.i851 = icmp eq i64 %30, 0
  br i1 %.not.i851, label %__barray_mask_borrow.exit853, label %panic.i852

panic.i852:                                       ; preds = %__barray_mask_return.exit850
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

__barray_mask_borrow.exit853:                     ; preds = %__barray_mask_return.exit850
  %31 = xor i64 %29, 4
  store i64 %31, i64* %11, align 4
  %32 = getelementptr inbounds i8, i8* %8, i64 16
  %33 = bitcast i8* %32 to i64*
  %34 = load i64, i64* %33, align 4
  tail call void @___rxy(i64 %34, double 0x400921FB54442D18, double 0.000000e+00)
  %35 = load i64, i64* %11, align 4
  %36 = and i64 %35, 4
  %.not.i854 = icmp eq i64 %36, 0
  br i1 %.not.i854, label %panic.i855, label %__barray_mask_return.exit856

panic.i855:                                       ; preds = %__barray_mask_borrow.exit853
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

__barray_mask_return.exit856:                     ; preds = %__barray_mask_borrow.exit853
  %37 = xor i64 %35, 4
  store i64 %37, i64* %11, align 4
  store i64 %34, i64* %33, align 4
  %38 = load i64, i64* %11, align 4
  %39 = and i64 %38, 8
  %.not.i857 = icmp eq i64 %39, 0
  br i1 %.not.i857, label %__barray_mask_borrow.exit859, label %panic.i858

panic.i858:                                       ; preds = %__barray_mask_return.exit856
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

__barray_mask_borrow.exit859:                     ; preds = %__barray_mask_return.exit856
  %40 = xor i64 %38, 8
  store i64 %40, i64* %11, align 4
  %41 = getelementptr inbounds i8, i8* %8, i64 24
  %42 = bitcast i8* %41 to i64*
  %43 = load i64, i64* %42, align 4
  tail call void @___rxy(i64 %43, double 0x400921FB54442D18, double 0.000000e+00)
  %44 = load i64, i64* %11, align 4
  %45 = and i64 %44, 8
  %.not.i860 = icmp eq i64 %45, 0
  br i1 %.not.i860, label %panic.i861, label %__barray_mask_return.exit862

panic.i861:                                       ; preds = %__barray_mask_borrow.exit859
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

__barray_mask_return.exit862:                     ; preds = %__barray_mask_borrow.exit859
  %46 = xor i64 %44, 8
  store i64 %46, i64* %11, align 4
  store i64 %43, i64* %42, align 4
  %47 = load i64, i64* %11, align 4
  %48 = and i64 %47, 512
  %.not.i863 = icmp eq i64 %48, 0
  br i1 %.not.i863, label %__barray_mask_borrow.exit865, label %panic.i864

panic.i864:                                       ; preds = %__barray_mask_return.exit862
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

__barray_mask_borrow.exit865:                     ; preds = %__barray_mask_return.exit862
  %49 = xor i64 %47, 512
  store i64 %49, i64* %11, align 4
  %50 = getelementptr inbounds i8, i8* %8, i64 72
  %51 = bitcast i8* %50 to i64*
  %52 = load i64, i64* %51, align 4
  tail call void @___rxy(i64 %52, double 0x400921FB54442D18, double 0.000000e+00)
  %53 = load i64, i64* %11, align 4
  %54 = and i64 %53, 512
  %.not.i866 = icmp eq i64 %54, 0
  br i1 %.not.i866, label %panic.i867, label %__barray_mask_return.exit868

panic.i867:                                       ; preds = %__barray_mask_borrow.exit865
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

__barray_mask_return.exit868:                     ; preds = %__barray_mask_borrow.exit865
  %55 = xor i64 %53, 512
  store i64 %55, i64* %11, align 4
  store i64 %52, i64* %51, align 4
  %56 = tail call i8* @heap_alloc(i64 240)
  %57 = bitcast i8* %56 to { i1, i64, i1 }*
  %58 = tail call i8* @heap_alloc(i64 8)
  %59 = bitcast i8* %58 to i64*
  store i64 -1, i64* %59, align 1
  br label %69

mask_block_ok.i.i.i:                              ; preds = %cond_exit_443.i
  %60 = load i64, i64* %11, align 4
  %61 = or i64 %60, -1024
  store i64 %61, i64* %11, align 4
  %62 = icmp eq i64 %61, -1
  br i1 %62, label %"__hugr__.$measure_array$$n(10).367.exit", label %mask_block_err.i.i.i

"__hugr__.$measure_array$$n(10).367.exit":        ; preds = %mask_block_ok.i.i.i
  tail call void @heap_free(i8* nonnull %8)
  tail call void @heap_free(i8* nonnull %10)
  %63 = tail call i8* @heap_alloc(i64 320)
  %64 = tail call i8* @heap_alloc(i64 8)
  %65 = bitcast i8* %64 to i64*
  store i64 0, i64* %65, align 1
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(320) %63, i8 0, i64 320, i1 false)
  %66 = load i64, i64* %59, align 4
  %67 = and i64 %66, 1023
  store i64 %67, i64* %59, align 4
  %68 = icmp eq i64 %67, 0
  br i1 %68, label %__barray_check_none_borrowed.exit, label %mask_block_err.i

mask_block_err.i.i.i:                             ; preds = %mask_block_ok.i.i.i
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @"e_Array cont.EFA5AC45.0", i64 0, i64 0))
  unreachable

69:                                               ; preds = %__barray_mask_return.exit868, %cond_exit_443.i
  %"393_0.sroa.15.0.i957" = phi i64 [ 0, %__barray_mask_return.exit868 ], [ %70, %cond_exit_443.i ]
  %70 = add nuw nsw i64 %"393_0.sroa.15.0.i957", 1
  %71 = lshr i64 %"393_0.sroa.15.0.i957", 6
  %72 = getelementptr inbounds i64, i64* %11, i64 %71
  %73 = load i64, i64* %72, align 4
  %74 = shl nuw nsw i64 1, %"393_0.sroa.15.0.i957"
  %75 = and i64 %73, %74
  %.not.i99.i.i = icmp eq i64 %75, 0
  br i1 %.not.i99.i.i, label %__barray_check_bounds.exit.i, label %panic.i.i.i

panic.i.i.i:                                      ; preds = %69
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

__barray_check_bounds.exit.i:                     ; preds = %69
  %76 = xor i64 %73, %74
  store i64 %76, i64* %72, align 4
  %77 = getelementptr inbounds i64, i64* %9, i64 %"393_0.sroa.15.0.i957"
  %78 = load i64, i64* %77, align 4
  %lazy_measure.i = tail call i64 @___lazy_measure(i64 %78)
  tail call void @___qfree(i64 %78)
  %79 = getelementptr inbounds i64, i64* %59, i64 %71
  %80 = load i64, i64* %79, align 4
  %81 = and i64 %80, %74
  %.not.i.i = icmp eq i64 %81, 0
  br i1 %.not.i.i, label %panic.i.i, label %cond_exit_443.i

panic.i.i:                                        ; preds = %__barray_check_bounds.exit.i
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

cond_exit_443.i:                                  ; preds = %__barray_check_bounds.exit.i
  %"457_054.fca.1.insert.i" = insertvalue { i1, i64, i1 } { i1 true, i64 poison, i1 poison }, i64 %lazy_measure.i, 1
  %82 = xor i64 %80, %74
  store i64 %82, i64* %79, align 4
  %83 = getelementptr inbounds { i1, i64, i1 }, { i1, i64, i1 }* %57, i64 %"393_0.sroa.15.0.i957"
  store { i1, i64, i1 } %"457_054.fca.1.insert.i", { i1, i64, i1 }* %83, align 4
  %exitcond973.not = icmp eq i64 %70, 10
  br i1 %exitcond973.not, label %mask_block_ok.i.i.i, label %69

__barray_check_none_borrowed.exit:                ; preds = %"__hugr__.$measure_array$$n(10).367.exit"
  %84 = tail call i8* @heap_alloc(i64 240)
  %85 = bitcast i8* %84 to { i1, i64, i1 }*
  %86 = tail call i8* @heap_alloc(i64 8)
  %87 = bitcast i8* %86 to i64*
  store i64 0, i64* %87, align 1
  %88 = bitcast i8* %63 to { i1, { i1, i64, i1 } }*
  br label %89

mask_block_err.i:                                 ; preds = %"__hugr__.$measure_array$$n(10).367.exit"
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

89:                                               ; preds = %__barray_check_none_borrowed.exit, %__hugr__.const_fun_338.322.exit
  %storemerge844962 = phi i64 [ 0, %__barray_check_none_borrowed.exit ], [ %107, %__hugr__.const_fun_338.322.exit ]
  %90 = phi i64 [ 0, %__barray_check_none_borrowed.exit ], [ %105, %__hugr__.const_fun_338.322.exit ]
  %91 = getelementptr inbounds { i1, i64, i1 }, { i1, i64, i1 }* %57, i64 %storemerge844962
  %92 = load { i1, i64, i1 }, { i1, i64, i1 }* %91, align 4
  %.fca.0.extract118.i = extractvalue { i1, i64, i1 } %92, 0
  %.fca.1.extract119.i = extractvalue { i1, i64, i1 } %92, 1
  br i1 %.fca.0.extract118.i, label %cond_513_case_1.i, label %cond_exit_513.i

cond_513_case_1.i:                                ; preds = %89
  tail call void @___inc_future_refcount(i64 %.fca.1.extract119.i)
  %93 = insertvalue { i1, i64, i1 } { i1 true, i64 poison, i1 poison }, i64 %.fca.1.extract119.i, 1
  br label %cond_exit_513.i

cond_exit_513.i:                                  ; preds = %cond_513_case_1.i, %89
  %.pn.i = phi { i1, i64, i1 } [ %93, %cond_513_case_1.i ], [ %92, %89 ]
  %"04.sroa.6.0.i" = extractvalue { i1, i64, i1 } %.pn.i, 2
  %exitcond974.not = icmp eq i64 %storemerge844962, 10
  br i1 %exitcond974.not, label %cond_516_case_0.i, label %94

94:                                               ; preds = %cond_exit_513.i
  %95 = lshr i64 %90, 6
  %96 = getelementptr inbounds i64, i64* %65, i64 %95
  %97 = load i64, i64* %96, align 4
  %98 = and i64 %90, 63
  %99 = shl nuw i64 1, %98
  %100 = and i64 %97, %99
  %.not.i.i870 = icmp eq i64 %100, 0
  br i1 %.not.i.i870, label %cond_516_case_1.i, label %panic.i.i871

panic.i.i871:                                     ; preds = %94
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @"e_Array elem.E746B1A3.0", i64 0, i64 0))
  unreachable

cond_516_case_0.i:                                ; preds = %cond_exit_513.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @"e_Expected v.E6312129.0", i64 0, i64 0))
  unreachable

cond_516_case_1.i:                                ; preds = %94
  %"17.fca.2.insert.i" = insertvalue { i1, i64, i1 } %92, i1 %"04.sroa.6.0.i", 2
  %101 = insertvalue { i1, { i1, i64, i1 } } { i1 true, { i1, i64, i1 } poison }, { i1, i64, i1 } %"17.fca.2.insert.i", 1
  %102 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %88, i64 %90
  %103 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %102, i64 0, i32 0
  %104 = load i1, i1* %103, align 1
  store { i1, { i1, i64, i1 } } %101, { i1, { i1, i64, i1 } }* %102, align 4
  br i1 %104, label %cond_517_case_1.i, label %__hugr__.const_fun_338.322.exit

cond_517_case_1.i:                                ; preds = %cond_516_case_1.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @"e_Expected v.2F17E0A9.0", i64 0, i64 0))
  unreachable

__hugr__.const_fun_338.322.exit:                  ; preds = %cond_516_case_1.i
  %105 = add nuw nsw i64 %90, 1
  %106 = getelementptr inbounds { i1, i64, i1 }, { i1, i64, i1 }* %85, i64 %storemerge844962
  store { i1, i64, i1 } %"17.fca.2.insert.i", { i1, i64, i1 }* %106, align 4
  %107 = add nuw nsw i64 %storemerge844962, 1
  %exitcond975.not = icmp eq i64 %107, 10
  br i1 %exitcond975.not, label %mask_block_ok.i875, label %89

mask_block_ok.i875:                               ; preds = %__hugr__.const_fun_338.322.exit
  tail call void @heap_free(i8* nonnull %56)
  tail call void @heap_free(i8* %58)
  %108 = load i64, i64* %65, align 4
  %109 = and i64 %108, 1023
  store i64 %109, i64* %65, align 4
  %110 = icmp eq i64 %109, 0
  br i1 %110, label %__barray_check_none_borrowed.exit877, label %mask_block_err.i876

mask_block_err.i876:                              ; preds = %mask_block_ok.i875
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

__barray_check_none_borrowed.exit877:             ; preds = %mask_block_ok.i875
  %111 = tail call i8* @heap_alloc(i64 240)
  %112 = bitcast i8* %111 to { i1, i64, i1 }*
  %113 = tail call i8* @heap_alloc(i64 8)
  %114 = bitcast i8* %113 to i64*
  store i64 0, i64* %114, align 1
  %115 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %88, align 4
  %.fca.0.extract11.i = extractvalue { i1, { i1, i64, i1 } } %115, 0
  br i1 %.fca.0.extract11.i, label %__hugr__.const_fun_287.338.exit, label %cond_558_case_0.i

cond_558_case_0.i:                                ; preds = %__hugr__.const_fun_287.338.exit.8, %__hugr__.const_fun_287.338.exit.7, %__hugr__.const_fun_287.338.exit.6, %__hugr__.const_fun_287.338.exit.5, %__hugr__.const_fun_287.338.exit.4, %__hugr__.const_fun_287.338.exit.3, %__hugr__.const_fun_287.338.exit.2, %__hugr__.const_fun_287.338.exit.1, %__hugr__.const_fun_287.338.exit, %__barray_check_none_borrowed.exit877
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @"e_Expected v.E6312129.0", i64 0, i64 0))
  unreachable

__hugr__.const_fun_287.338.exit:                  ; preds = %__barray_check_none_borrowed.exit877
  %116 = extractvalue { i1, { i1, i64, i1 } } %115, 1
  store { i1, i64, i1 } %116, { i1, i64, i1 }* %112, align 4
  %117 = getelementptr inbounds i8, i8* %63, i64 32
  %118 = bitcast i8* %117 to { i1, { i1, i64, i1 } }*
  %119 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %118, align 4
  %.fca.0.extract11.i.1 = extractvalue { i1, { i1, i64, i1 } } %119, 0
  br i1 %.fca.0.extract11.i.1, label %__hugr__.const_fun_287.338.exit.1, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.1:                ; preds = %__hugr__.const_fun_287.338.exit
  %120 = extractvalue { i1, { i1, i64, i1 } } %119, 1
  %121 = getelementptr inbounds i8, i8* %111, i64 24
  %122 = bitcast i8* %121 to { i1, i64, i1 }*
  store { i1, i64, i1 } %120, { i1, i64, i1 }* %122, align 4
  %123 = getelementptr inbounds i8, i8* %63, i64 64
  %124 = bitcast i8* %123 to { i1, { i1, i64, i1 } }*
  %125 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %124, align 4
  %.fca.0.extract11.i.2 = extractvalue { i1, { i1, i64, i1 } } %125, 0
  br i1 %.fca.0.extract11.i.2, label %__hugr__.const_fun_287.338.exit.2, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.2:                ; preds = %__hugr__.const_fun_287.338.exit.1
  %126 = extractvalue { i1, { i1, i64, i1 } } %125, 1
  %127 = getelementptr inbounds i8, i8* %111, i64 48
  %128 = bitcast i8* %127 to { i1, i64, i1 }*
  store { i1, i64, i1 } %126, { i1, i64, i1 }* %128, align 4
  %129 = getelementptr inbounds i8, i8* %63, i64 96
  %130 = bitcast i8* %129 to { i1, { i1, i64, i1 } }*
  %131 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %130, align 4
  %.fca.0.extract11.i.3 = extractvalue { i1, { i1, i64, i1 } } %131, 0
  br i1 %.fca.0.extract11.i.3, label %__hugr__.const_fun_287.338.exit.3, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.3:                ; preds = %__hugr__.const_fun_287.338.exit.2
  %132 = extractvalue { i1, { i1, i64, i1 } } %131, 1
  %133 = getelementptr inbounds i8, i8* %111, i64 72
  %134 = bitcast i8* %133 to { i1, i64, i1 }*
  store { i1, i64, i1 } %132, { i1, i64, i1 }* %134, align 4
  %135 = getelementptr inbounds i8, i8* %63, i64 128
  %136 = bitcast i8* %135 to { i1, { i1, i64, i1 } }*
  %137 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %136, align 4
  %.fca.0.extract11.i.4 = extractvalue { i1, { i1, i64, i1 } } %137, 0
  br i1 %.fca.0.extract11.i.4, label %__hugr__.const_fun_287.338.exit.4, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.4:                ; preds = %__hugr__.const_fun_287.338.exit.3
  %138 = extractvalue { i1, { i1, i64, i1 } } %137, 1
  %139 = getelementptr inbounds i8, i8* %111, i64 96
  %140 = bitcast i8* %139 to { i1, i64, i1 }*
  store { i1, i64, i1 } %138, { i1, i64, i1 }* %140, align 4
  %141 = getelementptr inbounds i8, i8* %63, i64 160
  %142 = bitcast i8* %141 to { i1, { i1, i64, i1 } }*
  %143 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %142, align 4
  %.fca.0.extract11.i.5 = extractvalue { i1, { i1, i64, i1 } } %143, 0
  br i1 %.fca.0.extract11.i.5, label %__hugr__.const_fun_287.338.exit.5, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.5:                ; preds = %__hugr__.const_fun_287.338.exit.4
  %144 = extractvalue { i1, { i1, i64, i1 } } %143, 1
  %145 = getelementptr inbounds i8, i8* %111, i64 120
  %146 = bitcast i8* %145 to { i1, i64, i1 }*
  store { i1, i64, i1 } %144, { i1, i64, i1 }* %146, align 4
  %147 = getelementptr inbounds i8, i8* %63, i64 192
  %148 = bitcast i8* %147 to { i1, { i1, i64, i1 } }*
  %149 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %148, align 4
  %.fca.0.extract11.i.6 = extractvalue { i1, { i1, i64, i1 } } %149, 0
  br i1 %.fca.0.extract11.i.6, label %__hugr__.const_fun_287.338.exit.6, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.6:                ; preds = %__hugr__.const_fun_287.338.exit.5
  %150 = extractvalue { i1, { i1, i64, i1 } } %149, 1
  %151 = getelementptr inbounds i8, i8* %111, i64 144
  %152 = bitcast i8* %151 to { i1, i64, i1 }*
  store { i1, i64, i1 } %150, { i1, i64, i1 }* %152, align 4
  %153 = getelementptr inbounds i8, i8* %63, i64 224
  %154 = bitcast i8* %153 to { i1, { i1, i64, i1 } }*
  %155 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %154, align 4
  %.fca.0.extract11.i.7 = extractvalue { i1, { i1, i64, i1 } } %155, 0
  br i1 %.fca.0.extract11.i.7, label %__hugr__.const_fun_287.338.exit.7, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.7:                ; preds = %__hugr__.const_fun_287.338.exit.6
  %156 = extractvalue { i1, { i1, i64, i1 } } %155, 1
  %157 = getelementptr inbounds i8, i8* %111, i64 168
  %158 = bitcast i8* %157 to { i1, i64, i1 }*
  store { i1, i64, i1 } %156, { i1, i64, i1 }* %158, align 4
  %159 = getelementptr inbounds i8, i8* %63, i64 256
  %160 = bitcast i8* %159 to { i1, { i1, i64, i1 } }*
  %161 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %160, align 4
  %.fca.0.extract11.i.8 = extractvalue { i1, { i1, i64, i1 } } %161, 0
  br i1 %.fca.0.extract11.i.8, label %__hugr__.const_fun_287.338.exit.8, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.8:                ; preds = %__hugr__.const_fun_287.338.exit.7
  %162 = extractvalue { i1, { i1, i64, i1 } } %161, 1
  %163 = getelementptr inbounds i8, i8* %111, i64 192
  %164 = bitcast i8* %163 to { i1, i64, i1 }*
  store { i1, i64, i1 } %162, { i1, i64, i1 }* %164, align 4
  %165 = getelementptr inbounds i8, i8* %63, i64 288
  %166 = bitcast i8* %165 to { i1, { i1, i64, i1 } }*
  %167 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %166, align 4
  %.fca.0.extract11.i.9 = extractvalue { i1, { i1, i64, i1 } } %167, 0
  br i1 %.fca.0.extract11.i.9, label %__hugr__.const_fun_287.338.exit.9, label %cond_558_case_0.i

__hugr__.const_fun_287.338.exit.9:                ; preds = %__hugr__.const_fun_287.338.exit.8
  %168 = extractvalue { i1, { i1, i64, i1 } } %167, 1
  %169 = getelementptr inbounds i8, i8* %111, i64 216
  %170 = bitcast i8* %169 to { i1, i64, i1 }*
  store { i1, i64, i1 } %168, { i1, i64, i1 }* %170, align 4
  tail call void @heap_free(i8* nonnull %63)
  tail call void @heap_free(i8* nonnull %64)
  br label %__barray_check_bounds.exit882

cond_169_case_0:                                  ; preds = %cond_exit_169
  %171 = load i64, i64* %114, align 4
  %172 = or i64 %171, -1024
  store i64 %172, i64* %114, align 4
  %173 = icmp eq i64 %172, -1
  br i1 %173, label %loop_out135, label %mask_block_err.i880

mask_block_err.i880:                              ; preds = %cond_169_case_0
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @"e_Array cont.EFA5AC45.0", i64 0, i64 0))
  unreachable

__barray_check_bounds.exit882:                    ; preds = %__hugr__.const_fun_287.338.exit.9, %cond_exit_169
  %"172_0.0984" = phi i64 [ 0, %__hugr__.const_fun_287.338.exit.9 ], [ %174, %cond_exit_169 ]
  %174 = add nuw nsw i64 %"172_0.0984", 1
  %175 = lshr i64 %"172_0.0984", 6
  %176 = getelementptr inbounds i64, i64* %114, i64 %175
  %177 = load i64, i64* %176, align 4
  %178 = shl nuw nsw i64 1, %"172_0.0984"
  %179 = and i64 %177, %178
  %.not = icmp eq i64 %179, 0
  br i1 %.not, label %__barray_mask_borrow.exit887, label %cond_exit_169

__barray_mask_borrow.exit887:                     ; preds = %__barray_check_bounds.exit882
  %180 = xor i64 %177, %178
  store i64 %180, i64* %176, align 4
  %181 = getelementptr inbounds { i1, i64, i1 }, { i1, i64, i1 }* %112, i64 %"172_0.0984"
  %182 = load { i1, i64, i1 }, { i1, i64, i1 }* %181, align 4
  %.fca.0.extract505 = extractvalue { i1, i64, i1 } %182, 0
  br i1 %.fca.0.extract505, label %cond_496_case_1, label %cond_exit_169

cond_exit_169:                                    ; preds = %cond_496_case_1, %__barray_mask_borrow.exit887, %__barray_check_bounds.exit882
  %183 = icmp ult i64 %"172_0.0984", 9
  br i1 %183, label %__barray_check_bounds.exit882, label %cond_169_case_0

loop_out135:                                      ; preds = %cond_169_case_0
  tail call void @heap_free(i8* %111)
  tail call void @heap_free(i8* nonnull %113)
  %184 = load i64, i64* %87, align 4
  %185 = and i64 %184, 1023
  store i64 %185, i64* %87, align 4
  %186 = icmp eq i64 %185, 0
  br i1 %186, label %__barray_check_none_borrowed.exit892, label %mask_block_err.i891

__barray_check_none_borrowed.exit892:             ; preds = %loop_out135
  %187 = tail call i8* @heap_alloc(i64 10)
  %188 = tail call i8* @heap_alloc(i64 8)
  %189 = bitcast i8* %188 to i64*
  store i64 0, i64* %189, align 1
  %190 = load { i1, i64, i1 }, { i1, i64, i1 }* %85, align 4
  %.fca.0.extract.i893 = extractvalue { i1, i64, i1 } %190, 0
  %.fca.1.extract.i894 = extractvalue { i1, i64, i1 } %190, 1
  br i1 %.fca.0.extract.i893, label %cond_300_case_1.i, label %cond_300_case_0.i

mask_block_err.i891:                              ; preds = %loop_out135
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

cond_496_case_1:                                  ; preds = %__barray_mask_borrow.exit887
  %.fca.1.extract506 = extractvalue { i1, i64, i1 } %182, 1
  tail call void @___dec_future_refcount(i64 %.fca.1.extract506)
  br label %cond_exit_169

cond_300_case_0.i:                                ; preds = %__barray_check_none_borrowed.exit892
  %.fca.2.extract.i = extractvalue { i1, i64, i1 } %190, 2
  br label %__hugr__.array.__read_bool.3.271.exit

cond_300_case_1.i:                                ; preds = %__barray_check_none_borrowed.exit892
  %read_bool.i = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894)
  br label %__hugr__.array.__read_bool.3.271.exit

__hugr__.array.__read_bool.3.271.exit:            ; preds = %cond_300_case_0.i, %cond_300_case_1.i
  %"03.0.i" = phi i1 [ %read_bool.i, %cond_300_case_1.i ], [ %.fca.2.extract.i, %cond_300_case_0.i ]
  %191 = bitcast i8* %187 to i1*
  store i1 %"03.0.i", i1* %191, align 1
  %192 = getelementptr inbounds i8, i8* %84, i64 24
  %193 = bitcast i8* %192 to { i1, i64, i1 }*
  %194 = load { i1, i64, i1 }, { i1, i64, i1 }* %193, align 4
  %.fca.0.extract.i893.1 = extractvalue { i1, i64, i1 } %194, 0
  %.fca.1.extract.i894.1 = extractvalue { i1, i64, i1 } %194, 1
  br i1 %.fca.0.extract.i893.1, label %cond_300_case_1.i.1, label %cond_300_case_0.i.1

cond_300_case_0.i.1:                              ; preds = %__hugr__.array.__read_bool.3.271.exit
  %.fca.2.extract.i.1 = extractvalue { i1, i64, i1 } %194, 2
  br label %__hugr__.array.__read_bool.3.271.exit.1

cond_300_case_1.i.1:                              ; preds = %__hugr__.array.__read_bool.3.271.exit
  %read_bool.i.1 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.1)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.1)
  br label %__hugr__.array.__read_bool.3.271.exit.1

__hugr__.array.__read_bool.3.271.exit.1:          ; preds = %cond_300_case_1.i.1, %cond_300_case_0.i.1
  %"03.0.i.1" = phi i1 [ %read_bool.i.1, %cond_300_case_1.i.1 ], [ %.fca.2.extract.i.1, %cond_300_case_0.i.1 ]
  %195 = getelementptr inbounds i8, i8* %187, i64 1
  %196 = bitcast i8* %195 to i1*
  store i1 %"03.0.i.1", i1* %196, align 1
  %197 = getelementptr inbounds i8, i8* %84, i64 48
  %198 = bitcast i8* %197 to { i1, i64, i1 }*
  %199 = load { i1, i64, i1 }, { i1, i64, i1 }* %198, align 4
  %.fca.0.extract.i893.2 = extractvalue { i1, i64, i1 } %199, 0
  %.fca.1.extract.i894.2 = extractvalue { i1, i64, i1 } %199, 1
  br i1 %.fca.0.extract.i893.2, label %cond_300_case_1.i.2, label %cond_300_case_0.i.2

cond_300_case_0.i.2:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.1
  %.fca.2.extract.i.2 = extractvalue { i1, i64, i1 } %199, 2
  br label %__hugr__.array.__read_bool.3.271.exit.2

cond_300_case_1.i.2:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.1
  %read_bool.i.2 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.2)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.2)
  br label %__hugr__.array.__read_bool.3.271.exit.2

__hugr__.array.__read_bool.3.271.exit.2:          ; preds = %cond_300_case_1.i.2, %cond_300_case_0.i.2
  %"03.0.i.2" = phi i1 [ %read_bool.i.2, %cond_300_case_1.i.2 ], [ %.fca.2.extract.i.2, %cond_300_case_0.i.2 ]
  %200 = getelementptr inbounds i8, i8* %187, i64 2
  %201 = bitcast i8* %200 to i1*
  store i1 %"03.0.i.2", i1* %201, align 1
  %202 = getelementptr inbounds i8, i8* %84, i64 72
  %203 = bitcast i8* %202 to { i1, i64, i1 }*
  %204 = load { i1, i64, i1 }, { i1, i64, i1 }* %203, align 4
  %.fca.0.extract.i893.3 = extractvalue { i1, i64, i1 } %204, 0
  %.fca.1.extract.i894.3 = extractvalue { i1, i64, i1 } %204, 1
  br i1 %.fca.0.extract.i893.3, label %cond_300_case_1.i.3, label %cond_300_case_0.i.3

cond_300_case_0.i.3:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.2
  %.fca.2.extract.i.3 = extractvalue { i1, i64, i1 } %204, 2
  br label %__hugr__.array.__read_bool.3.271.exit.3

cond_300_case_1.i.3:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.2
  %read_bool.i.3 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.3)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.3)
  br label %__hugr__.array.__read_bool.3.271.exit.3

__hugr__.array.__read_bool.3.271.exit.3:          ; preds = %cond_300_case_1.i.3, %cond_300_case_0.i.3
  %"03.0.i.3" = phi i1 [ %read_bool.i.3, %cond_300_case_1.i.3 ], [ %.fca.2.extract.i.3, %cond_300_case_0.i.3 ]
  %205 = getelementptr inbounds i8, i8* %187, i64 3
  %206 = bitcast i8* %205 to i1*
  store i1 %"03.0.i.3", i1* %206, align 1
  %207 = getelementptr inbounds i8, i8* %84, i64 96
  %208 = bitcast i8* %207 to { i1, i64, i1 }*
  %209 = load { i1, i64, i1 }, { i1, i64, i1 }* %208, align 4
  %.fca.0.extract.i893.4 = extractvalue { i1, i64, i1 } %209, 0
  %.fca.1.extract.i894.4 = extractvalue { i1, i64, i1 } %209, 1
  br i1 %.fca.0.extract.i893.4, label %cond_300_case_1.i.4, label %cond_300_case_0.i.4

cond_300_case_0.i.4:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.3
  %.fca.2.extract.i.4 = extractvalue { i1, i64, i1 } %209, 2
  br label %__hugr__.array.__read_bool.3.271.exit.4

cond_300_case_1.i.4:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.3
  %read_bool.i.4 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.4)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.4)
  br label %__hugr__.array.__read_bool.3.271.exit.4

__hugr__.array.__read_bool.3.271.exit.4:          ; preds = %cond_300_case_1.i.4, %cond_300_case_0.i.4
  %"03.0.i.4" = phi i1 [ %read_bool.i.4, %cond_300_case_1.i.4 ], [ %.fca.2.extract.i.4, %cond_300_case_0.i.4 ]
  %210 = getelementptr inbounds i8, i8* %187, i64 4
  %211 = bitcast i8* %210 to i1*
  store i1 %"03.0.i.4", i1* %211, align 1
  %212 = getelementptr inbounds i8, i8* %84, i64 120
  %213 = bitcast i8* %212 to { i1, i64, i1 }*
  %214 = load { i1, i64, i1 }, { i1, i64, i1 }* %213, align 4
  %.fca.0.extract.i893.5 = extractvalue { i1, i64, i1 } %214, 0
  %.fca.1.extract.i894.5 = extractvalue { i1, i64, i1 } %214, 1
  br i1 %.fca.0.extract.i893.5, label %cond_300_case_1.i.5, label %cond_300_case_0.i.5

cond_300_case_0.i.5:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.4
  %.fca.2.extract.i.5 = extractvalue { i1, i64, i1 } %214, 2
  br label %__hugr__.array.__read_bool.3.271.exit.5

cond_300_case_1.i.5:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.4
  %read_bool.i.5 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.5)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.5)
  br label %__hugr__.array.__read_bool.3.271.exit.5

__hugr__.array.__read_bool.3.271.exit.5:          ; preds = %cond_300_case_1.i.5, %cond_300_case_0.i.5
  %"03.0.i.5" = phi i1 [ %read_bool.i.5, %cond_300_case_1.i.5 ], [ %.fca.2.extract.i.5, %cond_300_case_0.i.5 ]
  %215 = getelementptr inbounds i8, i8* %187, i64 5
  %216 = bitcast i8* %215 to i1*
  store i1 %"03.0.i.5", i1* %216, align 1
  %217 = getelementptr inbounds i8, i8* %84, i64 144
  %218 = bitcast i8* %217 to { i1, i64, i1 }*
  %219 = load { i1, i64, i1 }, { i1, i64, i1 }* %218, align 4
  %.fca.0.extract.i893.6 = extractvalue { i1, i64, i1 } %219, 0
  %.fca.1.extract.i894.6 = extractvalue { i1, i64, i1 } %219, 1
  br i1 %.fca.0.extract.i893.6, label %cond_300_case_1.i.6, label %cond_300_case_0.i.6

cond_300_case_0.i.6:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.5
  %.fca.2.extract.i.6 = extractvalue { i1, i64, i1 } %219, 2
  br label %__hugr__.array.__read_bool.3.271.exit.6

cond_300_case_1.i.6:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.5
  %read_bool.i.6 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.6)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.6)
  br label %__hugr__.array.__read_bool.3.271.exit.6

__hugr__.array.__read_bool.3.271.exit.6:          ; preds = %cond_300_case_1.i.6, %cond_300_case_0.i.6
  %"03.0.i.6" = phi i1 [ %read_bool.i.6, %cond_300_case_1.i.6 ], [ %.fca.2.extract.i.6, %cond_300_case_0.i.6 ]
  %220 = getelementptr inbounds i8, i8* %187, i64 6
  %221 = bitcast i8* %220 to i1*
  store i1 %"03.0.i.6", i1* %221, align 1
  %222 = getelementptr inbounds i8, i8* %84, i64 168
  %223 = bitcast i8* %222 to { i1, i64, i1 }*
  %224 = load { i1, i64, i1 }, { i1, i64, i1 }* %223, align 4
  %.fca.0.extract.i893.7 = extractvalue { i1, i64, i1 } %224, 0
  %.fca.1.extract.i894.7 = extractvalue { i1, i64, i1 } %224, 1
  br i1 %.fca.0.extract.i893.7, label %cond_300_case_1.i.7, label %cond_300_case_0.i.7

cond_300_case_0.i.7:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.6
  %.fca.2.extract.i.7 = extractvalue { i1, i64, i1 } %224, 2
  br label %__hugr__.array.__read_bool.3.271.exit.7

cond_300_case_1.i.7:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.6
  %read_bool.i.7 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.7)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.7)
  br label %__hugr__.array.__read_bool.3.271.exit.7

__hugr__.array.__read_bool.3.271.exit.7:          ; preds = %cond_300_case_1.i.7, %cond_300_case_0.i.7
  %"03.0.i.7" = phi i1 [ %read_bool.i.7, %cond_300_case_1.i.7 ], [ %.fca.2.extract.i.7, %cond_300_case_0.i.7 ]
  %225 = getelementptr inbounds i8, i8* %187, i64 7
  %226 = bitcast i8* %225 to i1*
  store i1 %"03.0.i.7", i1* %226, align 1
  %227 = getelementptr inbounds i8, i8* %84, i64 192
  %228 = bitcast i8* %227 to { i1, i64, i1 }*
  %229 = load { i1, i64, i1 }, { i1, i64, i1 }* %228, align 4
  %.fca.0.extract.i893.8 = extractvalue { i1, i64, i1 } %229, 0
  %.fca.1.extract.i894.8 = extractvalue { i1, i64, i1 } %229, 1
  br i1 %.fca.0.extract.i893.8, label %cond_300_case_1.i.8, label %cond_300_case_0.i.8

cond_300_case_0.i.8:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.7
  %.fca.2.extract.i.8 = extractvalue { i1, i64, i1 } %229, 2
  br label %__hugr__.array.__read_bool.3.271.exit.8

cond_300_case_1.i.8:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.7
  %read_bool.i.8 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.8)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.8)
  br label %__hugr__.array.__read_bool.3.271.exit.8

__hugr__.array.__read_bool.3.271.exit.8:          ; preds = %cond_300_case_1.i.8, %cond_300_case_0.i.8
  %"03.0.i.8" = phi i1 [ %read_bool.i.8, %cond_300_case_1.i.8 ], [ %.fca.2.extract.i.8, %cond_300_case_0.i.8 ]
  %230 = getelementptr inbounds i8, i8* %187, i64 8
  %231 = bitcast i8* %230 to i1*
  store i1 %"03.0.i.8", i1* %231, align 1
  %232 = getelementptr inbounds i8, i8* %84, i64 216
  %233 = bitcast i8* %232 to { i1, i64, i1 }*
  %234 = load { i1, i64, i1 }, { i1, i64, i1 }* %233, align 4
  %.fca.0.extract.i893.9 = extractvalue { i1, i64, i1 } %234, 0
  %.fca.1.extract.i894.9 = extractvalue { i1, i64, i1 } %234, 1
  br i1 %.fca.0.extract.i893.9, label %cond_300_case_1.i.9, label %cond_300_case_0.i.9

cond_300_case_0.i.9:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.8
  %.fca.2.extract.i.9 = extractvalue { i1, i64, i1 } %234, 2
  br label %__hugr__.array.__read_bool.3.271.exit.9

cond_300_case_1.i.9:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.8
  %read_bool.i.9 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i894.9)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i894.9)
  br label %__hugr__.array.__read_bool.3.271.exit.9

__hugr__.array.__read_bool.3.271.exit.9:          ; preds = %cond_300_case_1.i.9, %cond_300_case_0.i.9
  %"03.0.i.9" = phi i1 [ %read_bool.i.9, %cond_300_case_1.i.9 ], [ %.fca.2.extract.i.9, %cond_300_case_0.i.9 ]
  %235 = getelementptr inbounds i8, i8* %187, i64 9
  %236 = bitcast i8* %235 to i1*
  store i1 %"03.0.i.9", i1* %236, align 1
  tail call void @heap_free(i8* nonnull %84)
  tail call void @heap_free(i8* nonnull %86)
  %237 = load i64, i64* %189, align 4
  %238 = and i64 %237, 1023
  store i64 %238, i64* %189, align 4
  %239 = icmp eq i64 %238, 0
  br i1 %239, label %__barray_check_none_borrowed.exit899, label %mask_block_err.i898

__barray_check_none_borrowed.exit899:             ; preds = %__hugr__.array.__read_bool.3.271.exit.9
  %out_arr_alloca = alloca <{ i32, i32, i1*, i1* }>, align 8
  %x_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 0
  %y_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 1
  %arr_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 2
  %mask_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 3
  %240 = alloca [10 x i1], align 1
  %.sub = getelementptr inbounds [10 x i1], [10 x i1]* %240, i64 0, i64 0
  %241 = bitcast [10 x i1]* %240 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(10) %241, i8 0, i64 10, i1 false)
  store i32 10, i32* %x_ptr, align 8
  store i32 1, i32* %y_ptr, align 4
  %242 = bitcast i1** %arr_ptr to i8**
  store i8* %187, i8** %242, align 8
  store i1* %.sub, i1** %mask_ptr, align 8
  call void @print_bool_arr(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @res_cs.46C3C4B5.0, i64 0, i64 0), i64 15, <{ i32, i32, i1*, i1* }>* nonnull %out_arr_alloca)
  br label %__barray_check_bounds.exit907

mask_block_err.i898:                              ; preds = %__hugr__.array.__read_bool.3.271.exit.9
  tail call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

__barray_check_bounds.exit907:                    ; preds = %cond_exit_95, %__barray_check_none_borrowed.exit899
  %"90_0.sroa.0.0966" = phi i64 [ 0, %__barray_check_none_borrowed.exit899 ], [ %243, %cond_exit_95 ]
  %243 = add nuw nsw i64 %"90_0.sroa.0.0966", 1
  %244 = lshr i64 %"90_0.sroa.0.0966", 6
  %245 = getelementptr inbounds i64, i64* %7, i64 %244
  %246 = load i64, i64* %245, align 4
  %247 = and i64 %"90_0.sroa.0.0966", 63
  %248 = shl nuw i64 1, %247
  %249 = and i64 %246, %248
  %.not.i908 = icmp eq i64 %249, 0
  br i1 %.not.i908, label %panic.i909, label %cond_exit_95

panic.i909:                                       ; preds = %__barray_check_bounds.exit907
  call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

cond_exit_95:                                     ; preds = %__barray_check_bounds.exit907
  %250 = xor i64 %246, %248
  store i64 %250, i64* %245, align 4
  %251 = getelementptr inbounds i64, i64* %5, i64 %"90_0.sroa.0.0966"
  store i64 %"90_0.sroa.0.0966", i64* %251, align 4
  %exitcond978.not = icmp eq i64 %243, 100
  br i1 %exitcond978.not, label %loop_out208, label %__barray_check_bounds.exit907

loop_out208:                                      ; preds = %cond_exit_95
  %252 = getelementptr inbounds i8, i8* %6, i64 8
  %253 = bitcast i8* %252 to i64*
  %254 = load i64, i64* %253, align 4
  %255 = and i64 %254, 68719476735
  store i64 %255, i64* %253, align 4
  %256 = load i64, i64* %7, align 4
  %257 = icmp eq i64 %256, 0
  %258 = icmp eq i64 %255, 0
  %or.cond = select i1 %257, i1 %258, i1 false
  br i1 %or.cond, label %__barray_check_none_borrowed.exit915, label %mask_block_err.i914

__barray_check_none_borrowed.exit915:             ; preds = %loop_out208
  %259 = call i8* @heap_alloc(i64 800)
  %260 = bitcast i8* %259 to i64*
  %261 = call i8* @heap_alloc(i64 16)
  %262 = bitcast i8* %261 to i64*
  call void @llvm.memset.p0i64.i64(i64* noundef nonnull align 1 dereferenceable(16) %262, i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0i64.p0i64.i64(i64* noundef nonnull align 1 dereferenceable(800) %260, i64* noundef nonnull align 1 dereferenceable(800) %5, i64 800, i1 false)
  call void @heap_free(i8* %259)
  %263 = load i64, i64* %253, align 4
  %264 = and i64 %263, 68719476735
  store i64 %264, i64* %253, align 4
  %265 = load i64, i64* %7, align 4
  %266 = icmp eq i64 %265, 0
  %267 = icmp eq i64 %264, 0
  %or.cond981 = select i1 %266, i1 %267, i1 false
  br i1 %or.cond981, label %__barray_check_none_borrowed.exit920, label %mask_block_err.i919

mask_block_err.i914:                              ; preds = %loop_out208
  call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

__barray_check_none_borrowed.exit920:             ; preds = %__barray_check_none_borrowed.exit915
  %out_arr_alloca282 = alloca <{ i32, i32, i64*, i1* }>, align 8
  %x_ptr283 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca282, i64 0, i32 0
  %y_ptr284 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca282, i64 0, i32 1
  %arr_ptr285 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca282, i64 0, i32 2
  %mask_ptr286 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca282, i64 0, i32 3
  %268 = alloca [100 x i1], align 1
  %.sub629 = getelementptr inbounds [100 x i1], [100 x i1]* %268, i64 0, i64 0
  %269 = bitcast [100 x i1]* %268 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(100) %269, i8 0, i64 100, i1 false)
  store i32 100, i32* %x_ptr283, align 8
  store i32 1, i32* %y_ptr284, align 4
  %270 = bitcast i64** %arr_ptr285 to i8**
  store i8* %4, i8** %270, align 8
  store i1* %.sub629, i1** %mask_ptr286, align 8
  call void @print_int_arr(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @res_is.F21393DB.0, i64 0, i64 0), i64 14, <{ i32, i32, i64*, i1* }>* nonnull %out_arr_alloca282)
  br label %__barray_check_bounds.exit928

mask_block_err.i919:                              ; preds = %__barray_check_none_borrowed.exit915
  call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

__barray_check_bounds.exit928:                    ; preds = %cond_exit_130, %__barray_check_none_borrowed.exit920
  %"125_0.sroa.0.0968" = phi i64 [ 0, %__barray_check_none_borrowed.exit920 ], [ %271, %cond_exit_130 ]
  %271 = add nuw nsw i64 %"125_0.sroa.0.0968", 1
  %272 = lshr i64 %"125_0.sroa.0.0968", 6
  %273 = getelementptr inbounds i64, i64* %3, i64 %272
  %274 = load i64, i64* %273, align 4
  %275 = and i64 %"125_0.sroa.0.0968", 63
  %276 = shl nuw i64 1, %275
  %277 = and i64 %274, %276
  %.not.i929 = icmp eq i64 %277, 0
  br i1 %.not.i929, label %panic.i930, label %cond_exit_130

panic.i930:                                       ; preds = %__barray_check_bounds.exit928
  call void @panic(i32 1002, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @"e_Array alre.5A300C2A.0", i64 0, i64 0))
  unreachable

cond_exit_130:                                    ; preds = %__barray_check_bounds.exit928
  %278 = sitofp i64 %"125_0.sroa.0.0968" to double
  %279 = fmul double %278, 6.250000e-02
  %280 = xor i64 %274, %276
  store i64 %280, i64* %273, align 4
  %281 = getelementptr inbounds double, double* %1, i64 %"125_0.sroa.0.0968"
  store double %279, double* %281, align 8
  %exitcond979.not = icmp eq i64 %271, 100
  br i1 %exitcond979.not, label %loop_out294, label %__barray_check_bounds.exit928

loop_out294:                                      ; preds = %cond_exit_130
  %282 = getelementptr inbounds i8, i8* %2, i64 8
  %283 = bitcast i8* %282 to i64*
  %284 = load i64, i64* %283, align 4
  %285 = and i64 %284, 68719476735
  store i64 %285, i64* %283, align 4
  %286 = load i64, i64* %3, align 4
  %287 = icmp eq i64 %286, 0
  %288 = icmp eq i64 %285, 0
  %or.cond982 = select i1 %287, i1 %288, i1 false
  br i1 %or.cond982, label %__barray_check_none_borrowed.exit936, label %mask_block_err.i935

__barray_check_none_borrowed.exit936:             ; preds = %loop_out294
  %289 = call i8* @heap_alloc(i64 800)
  %290 = bitcast i8* %289 to double*
  %291 = call i8* @heap_alloc(i64 16)
  %292 = bitcast i8* %291 to i64*
  call void @llvm.memset.p0i64.i64(i64* noundef nonnull align 1 dereferenceable(16) %292, i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0f64.p0f64.i64(double* noundef nonnull align 1 dereferenceable(800) %290, double* noundef nonnull align 1 dereferenceable(800) %1, i64 800, i1 false)
  call void @heap_free(i8* %289)
  %293 = load i64, i64* %283, align 4
  %294 = and i64 %293, 68719476735
  store i64 %294, i64* %283, align 4
  %295 = load i64, i64* %3, align 4
  %296 = icmp eq i64 %295, 0
  %297 = icmp eq i64 %294, 0
  %or.cond983 = select i1 %296, i1 %297, i1 false
  br i1 %or.cond983, label %__barray_check_none_borrowed.exit941, label %mask_block_err.i940

mask_block_err.i935:                              ; preds = %loop_out294
  call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable

__barray_check_none_borrowed.exit941:             ; preds = %__barray_check_none_borrowed.exit936
  %out_arr_alloca371 = alloca <{ i32, i32, double*, i1* }>, align 8
  %x_ptr372 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca371, i64 0, i32 0
  %y_ptr373 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca371, i64 0, i32 1
  %arr_ptr374 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca371, i64 0, i32 2
  %mask_ptr375 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca371, i64 0, i32 3
  %298 = alloca [100 x i1], align 1
  %.sub730 = getelementptr inbounds [100 x i1], [100 x i1]* %298, i64 0, i64 0
  %299 = bitcast [100 x i1]* %298 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(100) %299, i8 0, i64 100, i1 false)
  store i32 100, i32* %x_ptr372, align 8
  store i32 1, i32* %y_ptr373, align 4
  %300 = bitcast double** %arr_ptr374 to i8**
  store i8* %0, i8** %300, align 8
  store i1* %.sub730, i1** %mask_ptr375, align 8
  call void @print_float_arr(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @res_fs.CBD4AF54.0, i64 0, i64 0), i64 16, <{ i32, i32, double*, i1* }>* nonnull %out_arr_alloca371)
  ret void

mask_block_err.i940:                              ; preds = %__barray_check_none_borrowed.exit936
  call void @panic(i32 1002, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Some array.A77EF32E.0", i64 0, i64 0))
  unreachable
}

declare i8* @heap_alloc(i64) local_unnamed_addr

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i64.i64(i64* nocapture writeonly, i8, i64, i1 immarg) #0

; Function Attrs: noreturn
declare void @panic(i32, i8*) local_unnamed_addr #1

declare void @heap_free(i8*) local_unnamed_addr

declare void @___dec_future_refcount(i64) local_unnamed_addr

declare void @print_bool_arr(i8*, i64, <{ i32, i32, i1*, i1* }>*) local_unnamed_addr

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn
declare void @llvm.memcpy.p0i64.p0i64.i64(i64* noalias nocapture writeonly, i64* noalias nocapture readonly, i64, i1 immarg) #2

declare void @print_int_arr(i8*, i64, <{ i32, i32, i64*, i1* }>*) local_unnamed_addr

; Function Attrs: argmemonly mustprogress nofree nounwind willreturn
declare void @llvm.memcpy.p0f64.p0f64.i64(double* noalias nocapture writeonly, double* noalias nocapture readonly, i64, i1 immarg) #2

declare void @print_float_arr(i8*, i64, <{ i32, i32, double*, i1* }>*) local_unnamed_addr

declare i1 @___read_future_bool(i64) local_unnamed_addr

declare i64 @___lazy_measure(i64) local_unnamed_addr

declare void @___qfree(i64) local_unnamed_addr

declare i64 @___qalloc() local_unnamed_addr

declare void @___reset(i64) local_unnamed_addr

declare void @___rxy(i64, double, double) local_unnamed_addr

declare void @___inc_future_refcount(i64) local_unnamed_addr

define i64 @qmain(i64 %0) local_unnamed_addr {
entry:
  tail call void @setup(i64 %0)
  tail call fastcc void @__hugr__.main.1()
  %1 = tail call i64 @teardown()
  ret i64 %1
}

declare void @setup(i64) local_unnamed_addr

declare i64 @teardown() local_unnamed_addr

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #3

attributes #0 = { argmemonly mustprogress nofree nounwind willreturn writeonly }
attributes #1 = { noreturn }
attributes #2 = { argmemonly mustprogress nofree nounwind willreturn }
attributes #3 = { argmemonly nofree nounwind willreturn writeonly }

!name = !{!0}

!0 = !{!"mainlib"}
